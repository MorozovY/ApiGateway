#!/bin/bash
# Deployment Script для ApiGateway
# Story 13.5: Deployment Pipeline — Dev & Test Environments
#
# Использование:
#   ./deploy.sh [environment]
#
# Environments: dev, test
# Требуемые переменные окружения:
#   CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD
#   CI_REGISTRY_IMAGE, CI_COMMIT_SHA
#   DEPLOY_PATH (default: /opt/apigateway)

set -euo pipefail

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Конфигурация
ENVIRONMENT="${1:-dev}"
DEPLOY_PATH="${DEPLOY_PATH:-/opt/apigateway}"
COMPOSE_PROJECT="apigateway-${ENVIRONMENT}"
COMPOSE_FILE="${DEPLOY_PATH}/docker-compose.yml"
PREVIOUS_IMAGES_FILE="/tmp/previous_images_${ENVIRONMENT}.txt"
HEALTH_CHECK_RETRIES="${HEALTH_CHECK_RETRIES:-30}"
HEALTH_CHECK_INTERVAL="${HEALTH_CHECK_INTERVAL:-5}"

# Определяем путь к rollback.sh (CI vs local deployment)
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
if [ -f "${SCRIPT_DIR}/rollback.sh" ]; then
    ROLLBACK_SCRIPT="${SCRIPT_DIR}/rollback.sh"
elif [ -f "$ROLLBACK_SCRIPT" ]; then
    ROLLBACK_SCRIPT="$ROLLBACK_SCRIPT"
else
    ROLLBACK_SCRIPT="./docker/gitlab/rollback.sh"
fi

# Проверка обязательных переменных
check_required_vars() {
    local missing=0
    for var in CI_REGISTRY CI_REGISTRY_USER CI_REGISTRY_PASSWORD CI_REGISTRY_IMAGE CI_COMMIT_SHA; do
        if [ -z "${!var:-}" ]; then
            log_error "Required variable $var is not set"
            missing=1
        fi
    done
    if [ $missing -eq 1 ]; then
        exit 1
    fi
}

# Сохранение текущих image tags для rollback
save_previous_images() {
    log_info "Saving current image tags for rollback..."

    if [ -f "$COMPOSE_FILE" ]; then
        cd "$DEPLOY_PATH"
        # Сохраняем текущие image digests
        docker-compose -p "$COMPOSE_PROJECT" images -q 2>/dev/null | \
            xargs -r docker inspect --format='{{.RepoDigests}}' 2>/dev/null | \
            grep -oP '\[.*?\]' > "$PREVIOUS_IMAGES_FILE" || true

        # Также сохраняем image tags
        docker-compose -p "$COMPOSE_PROJECT" config 2>/dev/null | \
            grep 'image:' | awk '{print $2}' >> "$PREVIOUS_IMAGES_FILE" || true

        log_info "Previous images saved to $PREVIOUS_IMAGES_FILE"
    else
        log_warn "No existing deployment found, skipping previous images save"
    fi
}

# Логин в Container Registry
registry_login() {
    log_info "Logging into Container Registry..."
    echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    log_info "Registry login successful"
}

# Создание docker-compose.ci.yml для deployment
create_compose_override() {
    log_info "Creating docker-compose override for CI deployment..."

    local override_file="${DEPLOY_PATH}/docker-compose.ci.yml"

    cat > "$override_file" << EOF
# Auto-generated by deploy.sh
# Environment: ${ENVIRONMENT}
# Commit: ${CI_COMMIT_SHA}
# Generated: $(date -Iseconds)

version: '3.8'

services:
  gateway-admin:
    image: ${CI_REGISTRY_IMAGE}/gateway-admin:${CI_COMMIT_SHA}

  gateway-core:
    image: ${CI_REGISTRY_IMAGE}/gateway-core:${CI_COMMIT_SHA}

  admin-ui:
    image: ${CI_REGISTRY_IMAGE}/admin-ui:${CI_COMMIT_SHA}
EOF

    log_info "Override file created: $override_file"
}

# Pull новых images
pull_images() {
    log_info "Pulling new images..."

    local images=(
        "${CI_REGISTRY_IMAGE}/gateway-admin:${CI_COMMIT_SHA}"
        "${CI_REGISTRY_IMAGE}/gateway-core:${CI_COMMIT_SHA}"
        "${CI_REGISTRY_IMAGE}/admin-ui:${CI_COMMIT_SHA}"
    )

    for image in "${images[@]}"; do
        log_info "Pulling $image..."
        if ! docker pull "$image"; then
            log_error "Failed to pull $image"
            return 1
        fi
    done

    log_info "All images pulled successfully"
}

# Запуск контейнеров
deploy_containers() {
    log_info "Deploying containers..."

    cd "$DEPLOY_PATH"

    # Определяем compose files
    local compose_files="-f docker-compose.yml -f docker-compose.ci.yml"

    # Добавляем environment-specific override если существует
    local env_override="docker-compose.${ENVIRONMENT}.yml"
    if [ -f "$env_override" ]; then
        compose_files="$compose_files -f $env_override"
        log_info "Using environment override: $env_override"
    fi

    # Deploy с zero-downtime (recreate only changed)
    docker-compose -p "$COMPOSE_PROJECT" $compose_files up -d --remove-orphans

    log_info "Containers deployed"
}

# Health check для одного сервиса
check_service_health() {
    local service=$1
    local port=$2
    local health_endpoint=$3

    log_info "Checking health of $service..."

    for i in $(seq 1 $HEALTH_CHECK_RETRIES); do
        # Проверяем через docker-compose exec
        if docker-compose -p "$COMPOSE_PROJECT" exec -T "$service" \
            wget -q --spider "http://localhost:${port}${health_endpoint}" 2>/dev/null; then
            log_info "$service is healthy"
            return 0
        fi

        # Альтернативная проверка через curl если wget недоступен
        if docker-compose -p "$COMPOSE_PROJECT" exec -T "$service" \
            curl -sf "http://localhost:${port}${health_endpoint}" >/dev/null 2>&1; then
            log_info "$service is healthy"
            return 0
        fi

        log_warn "$service not ready yet (attempt $i/$HEALTH_CHECK_RETRIES)"
        sleep $HEALTH_CHECK_INTERVAL
    done

    log_error "$service health check failed after $HEALTH_CHECK_RETRIES attempts"
    return 1
}

# Полная проверка здоровья всех сервисов
health_check_all() {
    log_info "Running health checks..."

    local failed=0

    cd "$DEPLOY_PATH"

    # Gateway Admin
    if ! check_service_health "gateway-admin" "8081" "/actuator/health"; then
        failed=1
    fi

    # Gateway Core
    if ! check_service_health "gateway-core" "8080" "/actuator/health"; then
        failed=1
    fi

    # Admin UI (простая проверка HTTP 200)
    log_info "Checking health of admin-ui..."
    for i in $(seq 1 $HEALTH_CHECK_RETRIES); do
        if docker-compose -p "$COMPOSE_PROJECT" exec -T "admin-ui" \
            wget -q --spider "http://localhost:80/" 2>/dev/null || \
           docker-compose -p "$COMPOSE_PROJECT" exec -T "admin-ui" \
            curl -sf "http://localhost:80/" >/dev/null 2>&1; then
            log_info "admin-ui is healthy"
            break
        fi

        if [ $i -eq $HEALTH_CHECK_RETRIES ]; then
            log_error "admin-ui health check failed"
            failed=1
        fi

        log_warn "admin-ui not ready yet (attempt $i/$HEALTH_CHECK_RETRIES)"
        sleep $HEALTH_CHECK_INTERVAL
    done

    if [ $failed -eq 1 ]; then
        log_error "Health checks failed"
        return 1
    fi

    log_info "All health checks passed"
    return 0
}

# Основной процесс deployment
main() {
    log_info "=========================================="
    log_info "Starting deployment to ${ENVIRONMENT}"
    log_info "Commit: ${CI_COMMIT_SHA:-unknown}"
    log_info "Deploy path: ${DEPLOY_PATH}"
    log_info "=========================================="

    # Проверки
    check_required_vars

    # Создаём директорию если не существует
    mkdir -p "$DEPLOY_PATH"

    # Шаг 1: Сохраняем текущие images для rollback
    save_previous_images

    # Шаг 2: Логин в registry
    registry_login

    # Шаг 3: Создаём CI override
    create_compose_override

    # Шаг 4: Pull images
    if ! pull_images; then
        log_error "Failed to pull images"
        exit 1
    fi

    # Шаг 5: Deploy
    if ! deploy_containers; then
        log_error "Failed to deploy containers"
        # Пытаемся откатиться
        log_warn "Attempting rollback..."
        "$ROLLBACK_SCRIPT" "$ENVIRONMENT" || true
        exit 1
    fi

    # Шаг 6: Health checks
    if ! health_check_all; then
        log_error "Health checks failed"
        log_warn "Attempting rollback..."
        "$ROLLBACK_SCRIPT" "$ENVIRONMENT" || true
        exit 1
    fi

    log_info "=========================================="
    log_info "Deployment to ${ENVIRONMENT} SUCCESSFUL"
    log_info "=========================================="
}

# Запуск
main "$@"
